[{"_id": "FBr2rQgMspYLee649", "postedAt": "2022-12-16T18:35:13.157Z", "postId": "TMbPEhdAAJZsSYx2L", "htmlBody": "<p>A  friend referred me to this post \u2014 at the end of  a long message exchange about my reasons for why mechanistic interpretability does not and cannot contribute to long-term AGI  safety.</p>\n<p>Pasting my side of that message exchange below.</p>\n<p><em>Let me start with what I wrote near the end:</em></p>\n<blockquote>\n<p>The post \"The limited upside of interpretability\" is excellent btw.\nJust reading through, thank you.</p>\n</blockquote>\n<blockquote>\n<p>One claim I think is not capturing ecosystem complexity right is the computational irreducibility point.\nFlawlessly (ie. deterministically) computing an algorithm that has the shortest length (equivalent to Kolmogorov Complexity) of any algorithm that produces its outputs is <em>computationally irreducible</em> in the sense that you cannot just run a shorter-length algorithm requiring fewer computational operations to replace it.</p>\n</blockquote>\n<blockquote>\n<p>An ecosystem (whether based around carbon-centered DNA/RNA or solid-state-lattice-embedded-transistors) is <em>uncomputable</em>. This is because part interactions within that ecosystem do involve noise interference at various levels, that feed chaotic dynamics that in turn result in new formation of structure/parts. You simply cannot scan the parts of that ecosystem and simulate it faithfully on the equivalent of a Turing machine.</p>\n</blockquote>\n<blockquote>\n<p>You can make some higher-level predictions about long-term convergent outcomes of that ecosystem (as Forrest is doing, for parts of the human-carbon ecosystem in interactions with parts of the AI-solid-state ecosystem).</p>\n</blockquote>\n", "parentCommentId": null, "user": {"username": "remmelt"}}, {"_id": "2yGmtFEwKcdb7xTLq", "postedAt": "2022-12-16T20:08:22.497Z", "postId": "TMbPEhdAAJZsSYx2L", "htmlBody": "<p>\u2013&gt; Actually, my conversation partner is just double-checking where I quoted them. I intend to post the edited exchange here by Mon 26 Dec. [Update: they said it was fine]</p>", "parentCommentId": "FBr2rQgMspYLee649", "user": {"username": "remmelt"}}, {"_id": "jQHWWLSbvrFazxhc5", "postedAt": "2022-12-16T22:02:12.083Z", "postId": "TMbPEhdAAJZsSYx2L", "htmlBody": "<p><i>Most of my side of that message exchange (starting with a side-tangent):</i><br><br>On why I &nbsp;think Eliezer Yudkowsky does not try to advocate for people to try to prevent AGI from ever being built:</p><blockquote><p>[2:09 pm, 08/11/2022] Remmelt:<br>Yeah, good question!</p><p>My impression from reading recent writings by Eliezer is that he mentally models the social coordination problem (which is definitely hard) as practically impossible because you have all these independent actors making decisions about developing advanced AI systems and you cannot really force them in any grand orchestrated scheme to stop them from acting.</p><p>[2:10 pm, 08/11/2022] Remmelt:<br>&gt;&nbsp;Is he, relative to you, just too pessimistic that this is possible, [...]<br>And based on that he concludes something like you said.</p><p>[2:10 pm, 08/11/2022] Remmelt:<br>But humans are not independent actors. We\u2019re social actors, and social interactions imply a sort of interdependence in people\u2019s actions.</p><p>[2:12 pm, 08/11/2022] Remmelt:<br>Also, we share the same needs to continue to exist as wetware containing soups of carbon-chained molecules.</p><p>[2:12 pm, 08/11/2022] Remmelt:<br>And we share billions of years of shared evolutionary history.</p><p>[2:13 pm, 08/11/2022] Remmelt:<br>So there is a much stronger basis for human-human alignment for continued existence. Not so between humans and AI.</p><p>[2:13 pm, 08/11/2022] Remmelt:<br>Actually, let me copy over a longer message I sent someone for further context:</p><p>[2:18 pm, 08/11/2022] Remmelt:<br>A researcher emailed me that a long-standing intuition of his has been that \"Aligned AI\" is as much of a fairytale as a perpetual motion machine, and so we should just stop AI development. And that the reactions he got when expressing that view in the alignment community were usually something like \u201cWell that's just not going to happen, the capitalist forces driving R&amp;D cannot be overcome, so the best we can do is work tirelessly for the small but nonzero chance that we can successfully align AGI.\"</p><p>Here was my response:&nbsp;Yeah, I also got this reaction a few times.</p><p>It makes me wonder how these people mentally represent \"AGI\" to be like. Some common representational assumptions in the community seem to be that \"AGI\" would be (a) coherently goal-directed unitary agent(s) that optimise for specific outcomes across/within the outside messy world and that avoid causing any destabilising side-effects along the way.</p><p>I personally have a different take on this:<br>Their claim implies for me that for us humans to coordinate \u2013 as individual living bodies who can relate deeply based on their shared evolutionary history and needs for existence, is going to be harder than to 'build' perpetual alignment into machines that are completely alien to us and that over time can self-modify and connect up hardware any way they're driven to.</p><p>Here you bring this artificial form into existence that literally needs netherworldly conditions to continue to exist (survive) and expand its capacity (grow/reproduce). Where given the standardisation of its hardware/substrate configurations, it does not face the self-modification or information-bandwidth constraints that we humans, separated by our non-standardised wetware bodies (containing soups of carbon-centered-molecules), face.</p><p>This artificial form will act (both by greedy human design for automation and by instrumental convergence) to produce and preserve more (efficient) hardware infrastructure for optimising selected goals (ie. the directed functionality previously selected for by engineers and their optimisation methods, within the environmental contexts the AI was actually trained and deployed in).</p><p>These hardware-code internals will have degrees of freedom of interaction for/with changing conditions of the outside world that are for sure over the long term going to feed back into a subset of those existing internal configurations through their previous outside interactions replicating more frequently and sustainably through existing and newly produced hardware. Eg. through newly learned code variants co-opting functionality, inherent noise interference on the directivity/intensity of transmitted energy signals, side-branching effects on adjacent conditions of the environment, distribution shifts in the probabilities of possible inputs received from the environment, non-linear amplification of resulting outside effects through iterative feedback cycles, etc.</p><p>The resulting artificial forms will at various levels exchange resources with each other, and be selected by market forces for their capacities to produce similar to how humans are. And unlike humans, they are not separable as individual-band-width-constrained agents.</p><p>Some AIS researchers bring up the unilateralist curse here \u2013 that a few of the many human market/institutional actors out there would act unsafely out of line with the (implicit) consensus by developing unsafe AGI anyway. But if we are going to worry about humans' failure to coordinate, then getting all such conflicted humans to coordinate to externally enforce coordination on distributed self-learning hardware internals \u2013 that in aggregate exhibit general capabilities but have no definable stable unit boundaries \u2013 is definitely out of the question.</p></blockquote><p><br><br>On notion of built-in AGI-alignment</p><blockquote><p>[10:46 am, 10/11/2022] Remmelt:<br>&gt;&nbsp;I consider this more rhetorically interesting than an actual argument tbh.&nbsp;For example: I think the claim that these machines will be alien to us is too sloppy. We will build them ourselves. [\u2026]<br>&gt; Additionally, solving alignment may work without solving coordination problems. If alignment research reduces the alignment tax sufficiently, then *everyone* is incentiviced to use these solutions \u2014 there is no coordination problem. Additionally, coordination problems between AIs may not lead to disaster if these AIs are aligned and therefore all want to preserve human flourishing (whatever that means).<br><br>No, I think to be honest that you are assuming here that you can boil down something that is super complex in terms of how AGI internals are interacting with the world into an engineering problem, one that assumes that one alignment solution exists that everyone is going to agree with (where in actual fact people living in different contexts, eg. places and groups, disagree on what is objectively valuable and how to judge and implement what is valuable all the time).</p></blockquote><p><br><br>On a starting angle why mechanistic interpretability is a non-starter to begin with:</p><blockquote><p>[10:46 am, 10/11/2022] Remmelt:&nbsp;<br>&gt; And by mechanistic interpretability, we may eventually understand them better than the human brain since neuroscience is harder.</p><p>Mechanistic interpretability is a non-starter to begin with.</p><p>[11:34 am, 10/11/2022] Remmelt:<br>To start, you\u2019re inspecting internals. But what matters here is the effects that the (changing) internals\u2019 interactions with connected surroundings of the environment have.<br>So you actually have to account for interactions of a larger environment, not just the tiny subset of interactions that can be modelled as the (presumed flawless) computation of outputs from inputs by the underlying hardware.<br><br>[11:36 am, 10/11/2022] Remmelt:<br>So that is one clear reason why any interpretation technique or inspect internals technique is not going to be able to account for most of the effects that internals have in interaction with the outside environment.<br><br>[11:37 am, 10/11/2022] Remmelt:<br>It would also be unsound to assume that natural abstractions of features (as tracking some of the regularities in the outside world) that can be mechanistically interpreted is all that matters to ensure long-term AGI safety.</p></blockquote><p>&nbsp;</p><p>On other angles why mechanistic interpretability is insufficient &nbsp;(summarised briefly):</p><blockquote><p>[11:41 am, 10/11/2022] Remmelt:<br>Here is a list that includes other &nbsp;key reasons why mechanistic interpretability is not going to be sufficient in order to detect (or simulate) effects misaligned with human survival to correct (or prevent up front):</p><p>1. Non-Distinguished Internal Code Variants<br>Multiple variations on code can approximate the same function (outputs measured for distribution of inputs).</p><p>2. Unmeasured Degrees of Freedom<br>A single code unit can implement multiple functions.</p><p>3. Hidden Potential of a Computed Variant<br>Unknown probabilities of a code\u2006unit causing possible side-effects via available input/output interactions.</p><p>4. Greater Bit Size of Code that Monitors Any Code\u2019s Effects<br>Takes strictly more code\u2006(multiple\u2006units)\u2006to even monitor the local\u2006environmental\u2006effects of a single\u2006code\u2006unit.</p><p>5. Combinatorial Explosion in Machine Learning<br>It is increasingly\u2006ambiguous to define and detect novel\u2006errors to correct for at higher\u2006layers of abstraction.</p><p>6. Limits to Errors Detectable by Mechanisms Implemented<br>Code\u2006can\u2006implement a limited set of detection mechanisms over combinatorially\u2006complex\u2006code (incl. itself) that\u2006over all\u2006I/O\u2006connections\u2006could cause many\u2006more\u2006diverse\u2006errors than\u2006detectable by those mechanisms. Undetectable backdoors can be planted in the variations introduced by model initialisation and training.</p><p>7. Time Delays to Correcting Errors<br>Misalignments cannot be\u2006corrected continuously to stay\u2006in safe\u2006error\u2006bounds, given delays from detecting changes\u2006caused by code to measuring any\u2006degree\u2006of\u2006misalignment over semantically\u2006relevant\u2006dimensions.</p><p>8. Computationally-Irreducible Properties of Initialized Code &nbsp;(formal verification limits)<br>Whether even a tiny unit computed flawlessly (eg. a Busy Beaver) misoperates (eg. halts prematurely) is often only predictable (with logical certainty) by computing a copy faster (if future inputs computable, ie. not in ML).</p><p>9. Incompleteness of Computation &nbsp;(simulation limits)<br>Logical operations on binary code are strictly a subset of all interactions that internal code units have, as necessarily computed through hardware in interactions with connected surroundings of the environment. Since computation of code is a tiny subset of those physical interactions, code cannot model all of them.</p><p>10. Inconsistent Conservation of Alignment Properties<br>No mechanism(s) can maintain alignment over the space of all code stored + transformed over time, as (complex)\u2006(state/output)\u2006transitions\u2006of code\u2006variants change connected\u2006surroundings nondeterministically. You cannot run deterministic mechanisms within a nondeterministic environment and expect deterministic results.</p><p>11. Limits of Measurability<br>A sensor cannot measure (accurately) below its smallest digit increment or detection limit (&gt; Planck limit).<br>Localized details are filtered out from content or irreversibly distorted in transmission over distances.</p><p>12. Incomputable Trajectories of Chaotic Effects<br>Nonlinear feedback cycles can amplify a smaller-than-measurable local change into a large global divergence of final\u2006conditions (like DNA code being expressed as chaotic and extended phenotypic effects).&nbsp;<br>Natural abstractions represented within the mind of a distant observer cannot be used to accurately and comprehensively simulate the long-term consequences of chaotic interactions.</p><p>13. Local Selection Defines Directedness of Function Implementation<br>Variants\u2019 hardware-based interactions with local structures of the (simulated) environment get selected (in training/deployment) to function in directed ways. Functionality aligned with intent is fragile to distribution shifts. Correcting internals for detectable misalignments is selecting for undetectable misalignments.</p><p>14. Persistence of Function\u2006Implementations that Feed Back into\u2006Code\u2019s Continued Existence<br>AI variants\u2019 local interactions with the outside world happen to cause effects leading to the continued existence of more code with those effects. AI is not a neutral tool for augmenting human intelligence.<br><br>[11:46 am, 10/11/2022] Remmelt:<br>Regarding reason 2. and 3. above, here is more elaboration:</p><p>Any single piece of a neural network can capture various distinct structural causal effects, as selected for in its possible interactions with connected surroundings.</p><p>Below is an analogy:<br>A piece of a photograph captures one spatial detail or point location of the environment.&nbsp;<br>- Like how a programmer imagines a bit on a harddrive to capture a local logical property.&nbsp;<br>- Like how a reverse engineer assigns singular meanings to positions in memory.&nbsp;<br>- Like how a mechanistic interpretability researcher \u201cbreaks neural network activations into independently understandable pieces\u201d. (<a href=\"https://transformer-circuits.pub/2022/mech-interp-essay/index.html\">https://transformer-circuits.pub/2022/mech-interp-essay/index.html</a>)</p><p>A piece of a holograph, however, captures a point of reference overviewing various structures \u2013 structures of the environment that caused light waves to reflect and be captured as interference patterns on that piece of holographic film. The piece never just stores one static frame of the environment. Rotating it to change your degrees of interaction with it (ie. degrees of your viewing angle), the piece of holograph suddenly reveals previously hidden structures.<br>- Like a holograph piece, a neural network circuit or module captures causal structures of the environment but with many many more degrees of outside interaction possible.<br>- Like a holograph piece, a polysemantic neuron encodes multiple features in parallel.&nbsp; But most of the causal structure captured by circuits, modules and neural networks cannot be linearly (as series of additions and multiplications) pieced together from the input-output transformations of individual polysemantic neurons.&nbsp;<br>- Nor can we presume that a network of artificial neurons will be involved in some non-shifting distribution of interactions with the rest of the environment. To stretch the metaphor further, we cannot accurately predict how human users will interact with a developed holograph from moment to moment, nor how the probability distribution of all human-holograph interactions (over some fixed-length time window) will shift in the future (as eg. human cultural conceptions of holographs change). Unlike a holographic film though, pieces of a neural network themselves vary about in their content over time \u2013 newly capturing selected-for effects in interactions with the rest of the environment.<br>- Interpreting or reverse-engineering a circuit or module as having a singular function makes the unsound presumption of monolithic representation. Over the space of all possible past-future interactions, each piece (through each decoupled interface of interaction) can be expressed as having distinct meanings and functions.&nbsp;<br>- Similarly, we cannot carve out pieces of a human brain (\u2018neurons\u2019\u2018pathways\u2019\u2018regions\u2019) or body (\u2018cells\u2019\u2018organs\u2019) and assign just one function to each piece as being meaningful, no matter how much we may like to try.</p><p><br>Q: What about eliciting latent knowledge?</p><p>Where do you elicit this \u2018knowledge\u2019 from? A piece of code does not know how it got selected. A circuit gets selected for caused outputs/effects in interactions with surroundings. Interactions are not explicitly captured by outside selection \u2013 thus not reverse-engineerable from code itself.</p></blockquote><p>&nbsp;</p><p><br>On an overview of theoretical limits:</p><blockquote><p>[12:36 pm, 10/11/2022] Remmelt:<br>Here is another overview I wrote recently, with points 1.-2. particularly relevant whether simulating/detecting misalignment using mechanistic interpretability techniques is going to be sufficient for controlling the interactions of AGI internals with connected surroundings to prevent the build-up of human-species-wide lethal outside effects:<br><a href=\"https://docs.google.com/document/d/1-AAhqvgFNx_MlLkcSgw-chvmFoC4EZ4LmTl1IWcsqEA/edit\">https://docs.google.com/document/d/1-AAhqvgFNx_MlLkcSgw-chvmFoC4EZ4LmTl1IWcsqEA/edit</a></p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>Returning to overarching points why mechanistic interpretability falls short:</p><blockquote><p>[12:36 pm, 10/11/2022] Remmelt:<br>Anyway, that\u2019s a lot of stuff <img src=\"https://fonts.gstatic.com/s/e/notoemoji/15.0/1f642/32.png\" alt=\"\ud83d\ude42\"></p><p>[12:40 pm, 10/11/2022] Remmelt:<br>Just these two simple points above should already clarify why mechanistic interpretability falls short:</p><p>1. Computation is a tiny subset of internals\u2019 interactions with connected surroundings; mechanistic interpretability focusses on reverse engineering computed code itself to understand the resulting digital outputs, but ignores further environmental interactions.</p><p>2. It would also be unsound to assume that natural abstractions of features (as tracking some of the regularities in the outside world) that can be mechanistically interpreted is all that matters to ensure long-term AGI safety.<br>Link: <a href=\"https://mflb.com/ai_alignment_1/si_safety_qanda_out.html#p9\"><u>https://mflb.com/ai_alignment_1/si_safety_qanda_out.html#p9</u></a></p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>On fundamental dynamics that are outside the scope of application of mechanistic interpretability:</p><blockquote><p>[9:32 am, 11/11/2022] Remmelt:&nbsp;</p><p>&gt;&nbsp; Thanks for the answer!</p><p>&gt; I\u2019m not sure I understand this fully.<br>&gt; The following would be one interpretation<br>&gt; that is part of my own model<br>&gt; of why interpretability is difficult:</p><p>Thank you for the paraphrases.</p><p>I like the ideas, but I do mean more fundamental dynamics that are in some sense simpler than what you came up with.</p><p>If you have an AGI model that is learning new internal \u2018code variants\u2019 (introducing variations on the parameters of functional code units, eg. of neural network weights and biases) then we are not only concerned with what the model is thinking or behaving internally. We are concerned with how the outputs of the model are processed through the wider environment (that includes other agents like humans observing the represented outputs somehow and acting on those outputs as a result).</p><p>And unfortunately, we cannot use mechanistic interpretability to detect how the outputs (computed by code unit variants in aggregate, contingent on the inputs) are going to be processed and passed on as effects within the wider environment. Nor is any other measurement or data processing technique going to be able to account sufficiently for how outputs are processed through connected surroundings of the environment (natural abstractions simply will not be able to capture all the complex dynamics taking place in that bigger environment).</p><p>That is, not sufficient to account for how external effects of the model\u2019s operation will feed back into what sensor inputs the model might receive and in turn are transformed into new outputs, etc.</p><p>And also not how those external effects feed back into what (variants of) models even continue to physically exist (as configurations&nbsp;of a substrate) and function at increasing scale in the environment over time.</p></blockquote><p>&nbsp;</p><p><br>On whether I think mechanistic interpretability would be helpful at least:</p><blockquote><p>[9:40 am, 11/11/2022] Remmelt:<br>Helpful for interpreting narrow AI.</p><p>For any AGI development, mechanistic interpretability will basically give false confidence to engineers that they would actually be able to sufficiently detect misaligned&nbsp;effects of AGI.</p><p>For the leaders of AGI R&amp;D labs, mechanistic interpretability is a great marketing tool to show (visually) how their company is \u2018ensuring\u2019 their technology is \u2018safe and aligned\u2019. In other words, mechanistic interpretability will be used for \u2018align-washing\u2019 like how big fossil-fuel companies engage in green-washing.</p><p>Given that not having human society and the rest of our shared ecosystem destroyed seems like a priority above understanding and improving narrow AI, I have to conclude that current research efforts to do mechanistic interpretability are net really unhelpful.</p><p>AGI researchers and alignment researchers, can basically use it as a crotch to confirm that they can make progress (while missing/ignoring larger long-term problems).</p><p>&nbsp;</p><p>[9:45 am, 11/11/2022] Remmelt:<br>BTW, I\u2019m saying this because I want to be realistic and honest about what the current situation is, so we can act to safeguard life on Earth. I don\u2019t mean to be cynical. I mean to clarify things that are constructive for finding an alternate path forward.</p><p>[9:47 am, 11/11/2022] Remmelt:<br>Also, it\u2019s not fun to in effect tell people in your ingroup that the work they\u2019re doing is useless for AGI safety. I\u2019m really not personally benefiting from that, but it\u2019s important to get clear here.<br>[12:51 pm, 11/11/2022] Remmelt:<br>(I can respond to your responses on the overview list later, but want to be mindful of throwing too much at you at once. Seems better in our conversation to precisely dig into a few key statements and underlying cruxes).</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>On ways the reverse engineering analogy by Olah is unsound:</p><blockquote><p>[13:21, 11/11/2022] Remmelt:</p><p>&gt; See the answer by Chris Olah here on his vision why the curse of dimensionality may not be unsurpassable: <a href=\"https://transformer-circuits.pub/2022/mech-interp-essay/index.html\"><u>https://transformer-circuits.pub/2022/mech-interp-essay/index.html</u></a>&nbsp;</p><p>The problem IMO is that Chris Olah is making unsound representational assumptions (ie. unsound premises for how he can model interactions of code units) by comparing interpreting neural networks to reverse engineering code. Only at the end of his piece does he briefly mention the simplest least-hard-to-solve instance of the problem not addressed by his assembly-code reverse engineering analogy: polysemantic neurons.&nbsp;</p><p>Before we can make progress in our conversation here, or in any other part of our conversation, I first have to clarify why I think you (or Olah, etc) are making unsound representational assumptions&nbsp;</p><p>With the photograph vs. holograph analogy above, I tried to point at a different and IMO much more sound way of representing the functionality of code. But I get that this raises new questions about what definitions I'm using for terms, you want to precisely dig into the arguments step by step, etc.&nbsp;</p><p>So for now, I'll just email you a more specific list of reasons why the reverse engineering analogy is unsound, and leave it at that.</p><p><br>[Emailed list:]<br><strong>See below, only if you want to.</strong><br>Note: I split sentences into lines<br>to make any claim or argument<br>more parsable step-by-step.&nbsp;</p><p><br>&nbsp; &nbsp;Let me clarify below reasons<br>&nbsp; &nbsp;why I think Chris Olah's analogy between<br>&nbsp; &nbsp;reverse engineering software binaries/assembly<br>&nbsp; &nbsp;and mechanistic interpretability is unsound<br>&nbsp; &nbsp;when it comes to whether and how<br>&nbsp; &nbsp;one would sufficiently detect and correct&nbsp;<br>&nbsp; &nbsp;human-relevant errors in the code<br>&nbsp; &nbsp;of large neural&nbsp;network architectures<br>&nbsp; &nbsp;(particularly, any with general functionalities<br>&nbsp; &nbsp; to enact changes in the global environment).<br><br>&nbsp; &nbsp;What I meant to clarify here<br>&nbsp; &nbsp;was that the way one would<br>&nbsp; &nbsp;need to go about inspecting<br>&nbsp; &nbsp;all the combinatorial complexity<br>&nbsp; &nbsp;you would need to inspect<br>&nbsp; &nbsp;to interpret the functions<br>&nbsp; &nbsp;of NN-based architectures.<br>&nbsp; &nbsp;(particularly those exhibiting<br>&nbsp; &nbsp; general capabilities)<br>&nbsp; &nbsp;is much different than&nbsp;<br>&nbsp; &nbsp;the way you would go about<br>&nbsp; &nbsp;inspecting the binary/assembly code<br>&nbsp; &nbsp;of some kind of large software stack<br>&nbsp; &nbsp;running on a computer<br>&nbsp; &nbsp;(based on my amateur understanding<br>&nbsp; &nbsp; of what reverse engineering<br>&nbsp; &nbsp; software code usually involves).<br><br><br><strong>&nbsp; &nbsp;1. Combinatorial complexity</strong></p><p>&nbsp; &nbsp;There seem to be many many&nbsp;<br>&nbsp; &nbsp;more degrees of freedom of interaction<br>&nbsp; &nbsp;between all neurons (in/across layers) of an NN,<br>&nbsp; &nbsp;then you can expect to see across<br>&nbsp; &nbsp;the same amount of GB of binary code<br>&nbsp; &nbsp;of some software program,<br>&nbsp; &nbsp;which usually is much more constrained<br>&nbsp; &nbsp;in terms of the number of interactions<br>&nbsp; &nbsp;that are possible between possible elements<br>&nbsp; &nbsp;above some threshold<br>&nbsp; &nbsp;of negligible probability of the possibilities.</p><p>&nbsp; &nbsp;Of course, if you look at software function calls,<br>&nbsp; &nbsp;you can expect those&nbsp;to be reasonably complex as well<br>&nbsp; &nbsp;(definitely not as complicated as neural networks,<br>&nbsp; &nbsp; &nbsp;but a spaghetti nonetheless).</p><p><br>&nbsp; &nbsp;But initialised and stochastically selected<br>&nbsp; &nbsp;for collections of connected neurons are different<br>&nbsp; &nbsp;to having explicitly coded for functions<br>&nbsp; &nbsp;stored in particular parts of computer memory,<br>&nbsp; &nbsp;(where there is going to be just *some* messiness<br>&nbsp; &nbsp; around what functions/processes<br>&nbsp; &nbsp; call what functions).<br>&nbsp; &nbsp;For any prosaic NN-based AGI<br>&nbsp; &nbsp;all of&nbsp;the stupendous number<br>&nbsp; &nbsp;of neural network functions implementable&nbsp;<br>&nbsp; &nbsp;for all received inputs over time<br>&nbsp; &nbsp;by all learned/selected internal code units<br>&nbsp; &nbsp;through which human-relevant errors ('misalignments')<br>&nbsp; &nbsp;could be caused in the outside world<br>&nbsp; &nbsp;are just not trackable, by a very large margin.<br><br><br><strong>&nbsp; &nbsp;2. Possible meanings and functions</strong></p><p>&nbsp; &nbsp;As I tried to convey in the chapter 4,<br>&nbsp; &nbsp;it is unsound to assume<br>&nbsp; &nbsp;that a piece of a neural network<br>&nbsp; &nbsp;represents a single meaning<br>&nbsp; &nbsp;or causal function.<br><br>&nbsp; &nbsp;Chris Olah briefly refers<br>&nbsp; &nbsp;to polysemantic neurons in his piece.<br>&nbsp; &nbsp;But, as an example,<br>&nbsp; &nbsp;I think this *way* underplays<br>&nbsp; &nbsp;the amount of complexity<br>&nbsp; &nbsp;you have to deal with<br>&nbsp; &nbsp;in order to interpret all possible<br>&nbsp; &nbsp;'meanings' or 'functions' of a neural network<br>&nbsp; &nbsp;for all possible inputs and outputs<br>&nbsp; &nbsp;across all connected neurons<br>&nbsp; &nbsp;of the neural network<br>&nbsp; &nbsp; &nbsp;(going from first principles here;<br>&nbsp; &nbsp; &nbsp;I'm not an ML engineer).<br><br>&nbsp; &nbsp;I think that the following excerpt<br>&nbsp; &nbsp;of Chris Olah's post very much<br>&nbsp; &nbsp;understates the causal complexity<br>&nbsp; &nbsp;involved&nbsp;in interpreting neural networks:<br>&nbsp; &nbsp; \"Computer programs<br>&nbsp; &nbsp; &nbsp;often have memory layouts<br>&nbsp; &nbsp; &nbsp;that are convenient to understand...<br>&nbsp; &nbsp; &nbsp;Something kind of analogous to this<br>&nbsp; &nbsp; &nbsp;often happens in neural networks.<br>&nbsp; &nbsp; &nbsp;Let's assume for a moment<br>&nbsp; &nbsp; &nbsp;that neural networks can be understood<br>&nbsp; &nbsp; &nbsp;in terms of operations on a collection<br>&nbsp; &nbsp; &nbsp;of independent \"interpretable features\".<br>&nbsp; &nbsp; &nbsp; (from: <a href=\"https://transformer-circuits.pub/2022/mech-interp-essay/index.html\">https://transformer-circuits.pub/2022/mech-interp-essay/index.html</a>)<br><br><br><strong>&nbsp; &nbsp;3. Human priors for code representation</strong></p><p>&nbsp; &nbsp;My impression is that for reverse<br>&nbsp; &nbsp;engineering binary code,<br>&nbsp; &nbsp;you are (usually) interpreting<br>&nbsp; &nbsp;the binary code of functions<br>&nbsp; &nbsp;explicitly programmed by human programmers<br>&nbsp; &nbsp;that were compiled from one/a few<br>&nbsp; &nbsp;of a finite set of programming languages.<br><br>&nbsp; &nbsp;For interpreting&nbsp;pieces<br>&nbsp; &nbsp;of a neural networks though,<br>&nbsp; &nbsp;good practices and intuitions<br>&nbsp; &nbsp;are clearly different<br>&nbsp; &nbsp;than those used for<br>&nbsp; &nbsp;interpreting binary code<br>&nbsp; &nbsp;of software stacks.<br><br>&nbsp; &nbsp;And unlike complicated functions<br>&nbsp; &nbsp;programmed in by humans,<br>&nbsp; &nbsp;this is complexity we are<br>&nbsp; &nbsp;much less adapted to interpret,<br>&nbsp; &nbsp;evolutionarily and culturally.<br><br>&nbsp; &nbsp;We cannot assume somewhat<br>&nbsp; &nbsp;static programming representations and heuristics<br>&nbsp; &nbsp;that other computer programmers use<br>&nbsp; &nbsp;who are also primate mammals<br>&nbsp; &nbsp;that evolved roughly the same innate<br>&nbsp; &nbsp;learning biases / core knowledge<br>&nbsp; &nbsp;/ psychological constraints<br>&nbsp; &nbsp;(ie; innate priors<br>&nbsp; &nbsp; for the perceiving and representation<br>&nbsp; &nbsp; of observations as eg; bounded objects,<br>&nbsp; &nbsp; sortable things and persons, etc).<br><br><br><strong>&nbsp; &nbsp;4. Input distribution shifts</strong></p><p>&nbsp; &nbsp;A major problem with mechanistic interpretability<br>&nbsp; &nbsp;that I have not read Olah discuss online so far<br>&nbsp; &nbsp;are input distribution shifts.<br><br>&nbsp; &nbsp;Software models usually<br>&nbsp; &nbsp;are constrained in their input sets.<br>&nbsp; &nbsp;Input variables of software are<br>&nbsp; &nbsp;usually symbolically&nbsp;standardised<br>&nbsp; &nbsp;in ways that do not allow<br>&nbsp; &nbsp;for random cross-overs<br>&nbsp; &nbsp;in how the incoming data<br>&nbsp; &nbsp;are processed internally.<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp;Neural networks definitely do<br>&nbsp; &nbsp;get pseudo-random cross-overs<br>&nbsp; &nbsp;in terms of how&nbsp;functional code units&nbsp;<br>&nbsp; &nbsp;(neurons in a given layer)<br>&nbsp; &nbsp;process incoming data points.<br>&nbsp; &nbsp;Neural networks<br>&nbsp; &nbsp;(and other ML architectures)<br>&nbsp; &nbsp;are in effect function approximators<br>&nbsp; &nbsp;that select for 'transformation mappings'<br>&nbsp; &nbsp;between an (assumed)<br>&nbsp; &nbsp;probability distribution of inputs<br>&nbsp; &nbsp;to resulting computed outputs.<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;My impression is that&nbsp;<br>&nbsp; &nbsp;for most of the work Olah<br>&nbsp; &nbsp;has been doing on<br>&nbsp; &nbsp;mechanistically interpreting<br>&nbsp; &nbsp;NN-based architectures<br>&nbsp; &nbsp;that he implicitly relied upon that<br>&nbsp; &nbsp;the distribution of probabilities of inputs<br>&nbsp; &nbsp;would not shift significantly<br>&nbsp; &nbsp;beyond used training datasets.<br>&nbsp; &nbsp;Ie. Olah could just assume that<br>&nbsp; &nbsp;internal neurons/circuits/etc<br>&nbsp; &nbsp;will maintain roughly the same<br>&nbsp; &nbsp;'range' of functionality given&nbsp;<br>&nbsp; &nbsp;that the inputs are not going&nbsp;<br>&nbsp; &nbsp;to shift 'too much'.&nbsp;</p><p>&nbsp; &nbsp;However, we really cannot assume<br>&nbsp; &nbsp;that for any possible<br>&nbsp; &nbsp;prosaic AGI architecture.</p><p>&nbsp; &nbsp;Due to the implementation<br>&nbsp; &nbsp;of more general functionalities,<br>&nbsp; &nbsp;AGI would cause more<br>&nbsp; &nbsp;widespread and bigger changes<br>&nbsp; &nbsp;to ambient conditions and contexts<br>&nbsp; &nbsp;of the global environment<br>&nbsp; &nbsp;(which the architecture itself may<br>&nbsp; &nbsp; be moving through and changing its<br>&nbsp; &nbsp; input channels to over time).&nbsp;<br>&nbsp; &nbsp;Those changes would feed back<br>&nbsp; &nbsp;through whatever connected<br>&nbsp; &nbsp;input (sensor) channels of AGI<br>&nbsp; &nbsp;and result in distribution shifts&nbsp;<br>&nbsp; &nbsp;of AGI's expressed functionality.<br><br>&nbsp; &nbsp;So this gets back to chapter 1 and 2:<br>&nbsp; &nbsp;optimisation methods can initialise and select for<br>&nbsp; &nbsp;many different internal code unit variants<br>&nbsp; &nbsp;(eg. of NN weights, circuits, sub-networks)<br>&nbsp; &nbsp;that would within some&nbsp;assumed<br>&nbsp; &nbsp;probability distribution of possible inputs<br>&nbsp; &nbsp;function&nbsp;in *practically indistinguishable ways*<br>&nbsp; &nbsp;(ie. not distinguished by mechanistic&nbsp;<br>&nbsp; &nbsp; interpretability&nbsp;techniques used by Olah).</p><p>&nbsp; &nbsp;But once inputs go out of distribution.<br>&nbsp; &nbsp;model functionality shifts as&nbsp;well,<br>&nbsp; &nbsp;causing&nbsp;different outputs and outside effects.</p><p>&nbsp; &nbsp;<br><br><strong>&nbsp; &nbsp;5. Starting at a higher layer of abstraction</strong><br><br>&nbsp; &nbsp;Finally, and actually<br>&nbsp; &nbsp;not as relevant as the previous items,<br>&nbsp; &nbsp;you also start inspecting neurons<br>&nbsp; &nbsp;at a somewhat higher layer<br>&nbsp; &nbsp;of abstraction<br>&nbsp; &nbsp; &nbsp;(above matrix multiplications<br>&nbsp; &nbsp; &nbsp;as corresponding with<br>&nbsp; &nbsp; &nbsp;allowed biases of<br>&nbsp; &nbsp; &nbsp;and weighted connections<br>&nbsp; &nbsp; &nbsp;between neurons;<br>&nbsp; &nbsp; &nbsp;and perhaps above some interfaces<br>&nbsp; &nbsp; &nbsp;for distributed computation across servers<br>&nbsp; &nbsp; &nbsp;over network/internet protocols)<br>&nbsp; &nbsp;than for binary bits.</p></blockquote><p>&nbsp;</p><p><br>On &nbsp;destabilising internals\u2013environment feedback loops&nbsp;</p><blockquote><p>[18:25, 28/11/2022] Remmelt:<br>&gt; Okay, paraphrasing:<br>&gt; -- The model will produce outputs.<br>&gt; -- We will not know all effects of these outputs.<br>&gt; -- These effects will change the environment,<br>&gt; leading to changed inputs,<br>&gt; which (if the parameters are still updated)<br>&gt; leads to changed parameters<br>&gt; in a way that cannot be predicted.<br>&gt; I agree.<br>&gt; That's pretty obvious<br>&gt; and not yet a failure mode,<br>&gt; but I will read on</p><p>This is a fine paraphrase of the first claim about destabilising feedback cycles that would magnify input distribution shifts and resulting shifts in the functionality of AGI:<br>\"That is, not sufficient to account for how external effects of the model\u2019s operation will feed back into what sensor inputs the model might receive and in turn are transformed into new outputs, etc.\"</p><p>[Later edit: Ah, actually, the first claim about input-functionality shift feedback cycles is not just about learning different parameters with different inputs (although this is an important part, and I not thought about it yet for this specific dynamic).<br>It's mostly about inputs causing distribution shifts in outputs, which cause environmental effects that feed back as changes in (sensor) inputs.]</p><p>It does not cover the second claim, about substrate-needs convergence, which is what Forrest's research is about (the distribution-functionality shift feedback cycle is just one of a number of secondary dynamics that increase the speed of creep of AGI harmful effects).<br>\"And also not how those external effects feed back into what (variants of) models even continue to physically exist (as configurations of a substrate) and function at increasing scale in the environment over time.\"</p><p><br>Defined succinctly, substrate-needs convergence is:<br>That any changing population of AGI parts<br>\u2026that is, all manufactured/initialised components that are optimised for processing inputs into outputs such to in aggregate sense and act in many outside domains/context.<br>\u2026converges on propagating environmental effects that fulfil their artificial needs<br>that is, effects that keep feeding back into a portion of those artificial parts continuing to exist, function, and scale up as configurations of a (solid-state) substrate.</p><p>What is similar about claim 1 and 2 is that both are about feedback loops from outputs of computed/operated AGI internal components to external effects propagating through the environment, and then back again to affecting the functioning and existence of AGI components. The distribution-functionality shift feedback cycle is something inspect internals methods cannot account for, so I shared it with you as an intuitive step-up analogy for explaining why substrate-needs convergence can also not be dealt with using inspect internals methods.</p></blockquote><p>&nbsp;</p><p><br>On why \"inspect internals\" and \"inspect externals\" both fall short:</p><blockquote><p>[18:30, 28/11/2022] Remmelt:<br>&gt; I agree given the *premise*<br>&gt; that mechint isn't helpful for AGI alignment,<br>&gt; but don't yet see the reason for that premise</p><p>Mechanistic interpretability, as a technique for *inspecting internal components* for errors, cannot account for how the operation of AGI internal components causes outside effects propagating through the larger environment, and in turn feed back into the continued existence and functioning of some of those internal components, at increasing scales.</p><p>The scope of application of mechanistic interpretability is for *inspecting internals*, for errors that arise from *intrinsic selection of AGI code/hardware components through engineered optimisation methods*. It does not apply to *extrinsic* selection through effects across the wider environment. The scope of application of inspecting internals does not extend to the uncountable pathways through which AGI components' physical interactions loop back into the resulting selective continuity of existence, functioning and scaling of some of those components.</p><p>Code or hardware components do not intrinsically know what extensive causal history of prior physical interactions led to their current existence. You cannot \"elicit\" that knowledge from internal components, so you cannot detect errors resulting from extrinsic selection with internal inspection.</p><p>What's left is *external* inspection. Any implementable *externals* inspection/detection or modelling/simulation methods (or combinations thereof) will be *way too limited* in terms of capacity to detect misaligned self-substrate feedback loops in the interactions of AGI's changing internal components through changing available signalling channels with changing connected surroundings of the environment, over the long term.</p><p>So if external inspection methods are not going to cut it (to prevent AGI convergence on ecosystem-wide extinction), and the use of internal inspection methods' cannot functionally replace the use of external inspection methods (as outside the scope of application), then mechanistic interpretability as a method for internal inspection is simply not going to help with making AGI safe over the long run.</p><p>Specific inequalities you may want to dig into for grogging this abstract argument:<br>1. why no short-cut algorithm can assess the behavioural properties (digital outputs) of the, for practical purposes, arbitrary algorithms introduced internally by self-modifying AGI (analogous to Rice Theorem result).</p><p>2. why chaotic dynamics (non-linearly amplifying feedback cycles of potentially smaller-than-measurable localised effects) and complex dynamics of (the expression of multiple functional effects of) parts of a system are unpredictable and unsimulatable respectively, yet can still robustly lead to changes to the agent's body and environment (in eg. the expression of DNA code of biological organisms into adaptive phenotypic effects).</p><p>3. why aligning the external functioning of AGI internal components involves sensing relevant effects in the larger and more complex outside environment, and compressing that data in some *lossy* way to compare it against alignment references.</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>On &nbsp;NNs as spaghetti code</p><blockquote><p>[20:15, 28/11/2022] Remmelt:<br>&gt; Ah, I see you using the term spaghetti code btw.<br>&gt; Note that most people wouldn't<br>&gt; call neural networks \"spaghetti code\",<br>&gt; they mean hand-written unmaintainable code with it.<br>&gt; (Just saying it in case<br>&gt; &nbsp;it may help for avoiding confusions)</p><p>Thanks for the thought. I agree that's how the term \"spaghetti code\" is often used in context currently, so that might be a little confusing at first. As far as \"spaghetti code\" is defined literally as \"unstructured and difficult-to-maintain source code\", I think the term can be used in the contexts of neural network code too.</p><p>This conveys a big concern of neural networks \u2013 AI developers are prepared to deploy code for real-world use that is so messy to the point that no professional-minded software developer would accept such code from their colleague. Particularly for safety-critical applications that would amount to gross misconduct. It's a reason I hear why many industrial engineers have not switched from eg. decision tree algorithms to neural networks, despite the AI hype and benefits AI developers say their architectures have for being applied everywhere.</p></blockquote><p>&nbsp;</p><p><br>Returning to Olah's reverse engineering analogy:</p><blockquote><p>[21:25, 28/11/2022] Remmelt:<br>&gt; In general, most of the points seem<br>&gt; some variant of<br>&gt; \"The following aspect of mechint seems really hard\",<br>&gt; and people may agree with that<br>&gt; and view these as core difficulties,<br>&gt; and I may even agree that<br>&gt; they are not discussed enough publicly.<br>&gt; (I wouldn't claim that researchers<br>&gt; &nbsp;don't have these points in their internal models<br>&gt; &nbsp;of difficulties to be overcome --<br>&gt; &nbsp;there is only so much that researchers<br>&gt; &nbsp;can write down and express in a given day).</p><p>These are reasons that clarify why Olah's explanation of the reverse engineering analogy falls way short of capturing the complexity and risk of false negatives when inspecting large neural networks for human-relevant errors (misalignments).</p><p>If Olah already has any of these points as part of his mental model, then it is his responsibility to properly describe them in his writing, even briefly if he has other legitimate priorities, rather than sum up all the reasons why mechanistic interpretability is a problem that is the same kind of hard as interpreting the assembly code of software.</p><p>Note that any mistake of omitting a crucial aspect here can *lead to everyone dying down the line*.</p><p>If a surgeon inspecting the components of your body missed a crucial aspect in interpreting what your organs do, resulting in your death some years later, would you see that as acceptable professional conduct? What about a surgeon forgetting to teach crucial aspects of organ functioning to trainees in online documentation?</p><p>Analogously, can we just say, \"oops, oh yeah me being overly optimistic about our ability to interpret internal components led to the death of billions of people down the line\"?</p><p>&nbsp;</p><p>[21:28, 28/11/2022] Remmelt:<br>&gt; None of the points seem to destroy<br>&gt; the prospect of any value to be gained from mechint<br>&gt; for the alignment of AGI.</p><p>At the least, they result in a conclusion that the expected value is much lower than expected before.<br>If the prospect of mechanistically interpreting AGI internals comprehensively to prevent ecosystem-wide extinction turns out a lot more pessimistic than thought earlier, that means the expected value of working on mechanistic interpretability is also much lower.<br>&nbsp;</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>On the key sub-arguments for why long-term safe AGI is impossible:</p><blockquote><p>[21:34, 28/11/2022] Remmelt:<br>&gt; Can you maybe mention the single,<br>&gt; in your view strongest, argument<br>&gt; that tries to make alignment of advanced AI<br>&gt; impossible or extremely unlikely?<br>&gt; Maybe you mentioned it already above<br>&gt; in the parts of your second to last message stream<br>&gt; which I ignored, then you can also point me to it.</p><p>If you want the conclusive argument, this requires understanding three key sub-arguments first.</p><p>One sub-argument is about theoretical limits of engineerable control, so perhaps you can start there?</p><p>The other two sub-arguments are about:<br>- economic decoupling of AI exchanges of value from human exchanges of value.<br>- substrate-needs convergence (as distinct from but enabled by instrumental convergence).</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>On ecosystems being uncomputable:</p><blockquote><p>[22:14, 28/11/2022] Remmelt:<br>&gt; <a href=\"https://forum.effectivealtruism.org/posts/TMbPEhdAAJZsSYx2L/the-limited-upside-of-interpretability\">https://forum.effectivealtruism.org/posts/TMbPEhdAAJZsSYx2L/the-limited-upside-of-interpretability</a><br>&gt; This seems similar to some of your concerns<br>&nbsp;</p><p>The post \"The limited upside of interpretability\" is excellent btw.<br>Just reading through, thank you.</p><p>One claim I think is not capturing ecosystem complexity right is the computational irreducibility point.<br>Flawlessly (ie. deterministically) computing an algorithm that has the shortest length (equivalent to Kolmogorov Complexity) of any algorithm that produces its outputs is *computationally irreducible* in the sense that you cannot just run a shorter-length algorithm requiring fewer computational operations to replace it.</p><p>An ecosystem (whether based around carbon-centered DNA/RNA or solid-state-lattice-embedded-transistors) is *uncomputable*. This is because part interactions within that ecosystem do involve noise interference at various levels, that feed chaotic dynamics that in turn result in new formation of structure/parts. You simply cannot scan the parts of that ecosystem and simulate it faithfully on the equivalent of a Turing machine.</p><p>You can make some higher-level predictions about long-term convergent outcomes of that ecosystem (as Forrest is doing, for parts of the human-carbon ecosystem in interactions with parts of the AI-solid-state ecosystem).</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>Original researcher's response on theoretical limits of engineerable control:</p><blockquote><p>[09:51, 29/11/2022] Remmelt:<br>Regarding theoretical limits<br>of engineerable control,<br>Forrest just emailed me this:</p><p>\u201cFor the aspect that has to do with technical&nbsp;<br>non-alignment, the key info is the following:.</p><p>&nbsp;- that any and every AGI 'safety/alignment' process<br>&nbsp;is a special case of a 'causative feedback process'.<br>&nbsp; &nbsp;- that there are no/zero exceptions to this truth.<br>&nbsp; &nbsp;- as anything and everything that is true of&nbsp;<br>&nbsp; &nbsp;the use of causation, as a feedback process,&nbsp;<br>&nbsp; &nbsp;and/or an 'algorithm', also as a 'modeling process',<br>&nbsp; &nbsp;and/or of 'signaling', inherent in any 'feedback',<br>&nbsp; &nbsp;will for sure be true also of any AGI safety/alignment<br>&nbsp; &nbsp;technique, method, proposal, methodology, algorithm, etc.</p><p>&nbsp;- that any and every 'causative feedback process'<br>&nbsp;depends on at least all of the following:.</p><p>&nbsp; &nbsp;- 1; the completeness of the sense input.<br>&nbsp; &nbsp; &nbsp;- as the input data that is being processed by&nbsp;<br>&nbsp; &nbsp; &nbsp;or used by, the proposed AGI alignment technique/etc,<br>&nbsp; &nbsp; &nbsp;and also as the input data that is intake into&nbsp;<br>&nbsp; &nbsp; &nbsp;the AGI system, so that the model of the key aspects<br>&nbsp; &nbsp; &nbsp;of the AGI system has reasonably correct input data.</p><p>&nbsp; &nbsp;- 2; the completeness of process modelability.<br>&nbsp; &nbsp; &nbsp;- ie; that the proposed AGI alignment technique/etc,<br>&nbsp; &nbsp; &nbsp;has to actually be that, some sort of algorithm,<br>&nbsp; &nbsp; &nbsp;itself conditional on only causation and logic<br>&nbsp; &nbsp; &nbsp;and that the AGI system itself has to be&nbsp;<br>&nbsp; &nbsp; &nbsp;at least partially modelable, in whatever key<br>&nbsp; &nbsp; &nbsp;aspects, are necessary to establish 'alignment'.<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp;- 3; the completeness of predictability.<br>&nbsp; &nbsp; &nbsp;- ie; as the assumption that the model&nbsp;<br>&nbsp; &nbsp; &nbsp;of the AGI system&nbsp;<br>&nbsp; &nbsp; &nbsp;when also given the model of the input data<br>&nbsp; &nbsp; &nbsp;will allow for sufficient predictability<br>&nbsp; &nbsp; &nbsp;of whatever key aspects of the future AGI outputs<br>&nbsp; &nbsp; &nbsp;will be, before the real (non-modeled) AGI&nbsp;<br>&nbsp; &nbsp; &nbsp;would actually act, in a way that is assessable<br>&nbsp; &nbsp; &nbsp;and comparable to desired outcome states.</p><p>&nbsp; &nbsp;- 4; the completeness of some type of a comparison&nbsp;<br>&nbsp; &nbsp;to a reference (where that reference implicitly defines&nbsp;<br>&nbsp; &nbsp;whatever is the meaning of \"aligned\" or \"safe\").</p><p>&nbsp; &nbsp;- 5; the completeness of some type of signaling&nbsp;<br>&nbsp; &nbsp;(ie; what is the \"feedback\", how the model itself<br>&nbsp; &nbsp;works internally, how the model alerts the actuator<br>&nbsp; &nbsp;so that the model 'controls' and constrains the AGI&nbsp;<br>&nbsp; &nbsp;so that it is acting/operating in an aligned way).</p><p>&nbsp; &nbsp;- 6; the completeness of some type of&nbsp;<br>&nbsp; &nbsp;conditionalization (ie, what is \"effectiveness\")<br>&nbsp; &nbsp;of at least one of&nbsp;<br>&nbsp; &nbsp;the following AGI aspects:.<br>&nbsp; &nbsp; &nbsp;- output actions.<br>&nbsp; &nbsp; &nbsp;- internal process.<br>&nbsp; &nbsp; &nbsp;- sense input.</p><p>&nbsp; &nbsp; - ie; where/if the AGI conditionalization&nbsp;<br>&nbsp; &nbsp; does not have sufficient \"power\" to actually constrain<br>&nbsp; &nbsp; the AGI from doing bad things, then even a very good<br>&nbsp; &nbsp; alignment algorithm/technique/process will not result<br>&nbsp; &nbsp; in an aligned/safe AGI.</p><p>&nbsp;- that aspects 1 thru 6 (inclusive) are true of any&nbsp;<br>&nbsp;and every 'causative feedback process'.<br>&nbsp; &nbsp;- that there are exactly none/zero exceptions.<br>&nbsp; &nbsp;- that all causative feedback process&nbsp;<br>&nbsp; &nbsp;will have/require all six of these aspects&nbsp;<br>&nbsp; &nbsp;(with no exceptions).</p><p>&nbsp;- that therefore, a/the/any/all AGI alignment/safety<br>&nbsp;enforcement protocols, techniques, methodologies, etc,<br>&nbsp;will also (for sure) be required to have and implement&nbsp;<br>&nbsp;all six aspects (with no exceptions),&nbsp;<br>&nbsp;and, where given that requirement,&nbsp;<br>&nbsp;if any of these six aspects, for whatever reason,&nbsp;<br>&nbsp;cannot be implemented, then that/therefore&nbsp;<br>&nbsp;AGI alignment/safety cannot be implemented.</p><p>&nbsp;Unfortunately, every single one of the listed&nbsp;<br>&nbsp;dependencies (all six of them) are individually impossible&nbsp;<br>&nbsp; &nbsp;(ie; cannot be 'complete enough' to achieve&nbsp;<br>&nbsp; &nbsp;anywhere near the minimum threshold necessary).<br>&nbsp;Insofar as all six are necessary together&nbsp;<br>&nbsp;to achieve AGI alignment, that there are effectively six,&nbsp;<br>&nbsp;at least semi-independent, arguments against&nbsp;<br>&nbsp;there being any notion of AGI alignment,&nbsp;<br>&nbsp;as based on nothing outside fo the notions of<br>&nbsp;causation, conditionalization, and/or logic<br>&nbsp;(ie, all different manifestations of the same idea).<br>\u2026<br>&nbsp;Moreover, the control and/or \"error correction\" system&nbsp;<br>&nbsp;must itself not make mistakes/errors (ie, be/operate<br>&nbsp;within reasonable limits, be itself predictable, etc).&nbsp;<br>&nbsp;What tracks errors/mistakes in the system&nbsp;<br>&nbsp;that is modeling the system to apply error correction to? &nbsp;<br>&nbsp;Insofar as the same logic applies in proportion to the<br>&nbsp;complexity of the error correction, as it does in the<br>&nbsp;complexity of the AGI system itself, then there is a&nbsp;<br>&nbsp;kind of regression cascade problem.\u201d</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>Original researcher's response on mechanistic interpretability:</p><blockquote><p>[09:51, 29/11/2022] Remmelt:<br>And on mechanistic interpretability:<br>\"Maybe 'mechanistic interpretability' arguments<br>always ends up confusing things in regards to&nbsp;<br>the argument of AGI safety impossibility?</p><p>The notion that might make some of this easier<br>is to describe it as \"dual use functionality\"<br>that occurs at the small scale, in a distributed way,<br>and which will eventually result in unexpected<br>shifts in macroscopic results/outcomes.</p><p>No one bothers to try to 'observe' and 'interpret<br>or describe the meaning/function of', or outcome,&nbsp;<br>of what is happening in the small details&nbsp;<br>in any NN or system.&nbsp; Hence, subtle exogenously<br>coordinated shifts occurring everywhere at once<br>will routinely get overlooked.</p><p>'Mechanistic interpretability' frames things in<br>terms of single macroscopic functions/descriptions.<br>That leads to a confusing focus, insofar as people<br>believe that is the only way to think about it.<br>Our work is about functions with plural microscopic<br>drivers/outcomes, and what sort of implications&nbsp;<br>that has.\u201d</p></blockquote>", "parentCommentId": "FBr2rQgMspYLee649", "user": {"username": "remmelt"}}]